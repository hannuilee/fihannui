*&---------------------------------------------------------------------*
*& Report ZRSUWON_215_01
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT ZRTEST_215_01.
"I, P, N, D, T, C

"I 설명
DATA : GV_NUM1 TYPE I.
DATA : GV_NUM2 TYPE I.

GV_NUM1 = 1.
GV_NUM2 = 2.

WRITE : GV_NUM1, GV_NUM2.

DATA : GV_NUM3 TYPE I.
DATA : GV_NUM4 LIKE GV_NUM1.

GV_NUM3 = 3.
GV_NUM4 = 4.

NEW-LINE.
WRITE : GV_NUM3, GV_NUM4.

GV_NUM3 = GV_NUM4.
NEW-LINE.
WRITE : '99999999999999999999999'.
NEW-LINE.
WRITE : GV_NUM3, GV_NUM4.

MOVE GV_NUM3 TO GV_NUM4.
NEW-LINE.
WRITE : '99999999999999999999999'.
NEW-LINE.
WRITE : GV_NUM3, GV_NUM4.

CLEAR GV_NUM3.
CLEAR GV_NUM4.
CLEAR : GV_NUM3, GV_NUM4.

TYPES T_NUM33 TYPE I.
DATA : GV_NUM33 TYPE T_NUM33.

GV_NUM33 = 1.
NEW-LINE.
WRITE : GV_NUM33.

CONSTANTS GV_NUM44 TYPE I VALUE 10.

*GV_NUM44 = GV_NUM44 + 1. "에러남

WRITE : / GV_NUM44.

"N 설명
DATA : GV_NUM5 TYPE I VALUE 5.
DATA : GV_NUM6 TYPE N LENGTH 4 VALUE '23'.

DATA : GV_NUM6_2 TYPE N VALUE '1234'.
DATA : GV_NUM6_3 TYPE N LENGTH 2 VALUE '1234'.
DATA : GV_NUM6_4 TYPE N LENGTH 3 VALUE '1234'.
DATA : GV_NUM6_5 TYPE N LENGTH 4 VALUE '1234'.
DATA : GV_NUM6_6 TYPE N LENGTH 5 VALUE '1234'.

NEW-LINE.
WRITE : GV_NUM5, GV_NUM6.

MOVE GV_NUM5 TO GV_NUM6.
NEW-LINE.
WRITE : GV_NUM5, GV_NUM6.

NEW-LINE.
WRITE : GV_NUM6_2, GV_NUM6_3,
        GV_NUM6_4, GV_NUM6_5,
        GV_NUM6_6.

"P 설명
"소수는 최대 14자리까지 사용
"1~16BYTE까지 선언 / BYTE X 2 - 1 만큼 자릿수가 먹음
"선언하지 않으면 기본 8 BYTE로 15자리까지 가능
*DATA : GV_NUM7 TYPE P LENGTH 8 DECIMALS 3 VALUE '2.34'.
DATA : GV_NUM7 TYPE P DECIMALS 3 VALUE '2.34'.

DATA : GV_NUM77 TYPE P DECIMALS 2
      VALUE '1234567890123.34'.

*"소숫점 자리까지 포함하여 15자리가 넘으면 오버플로우
*DATA : GV_NUM77 TYPE P DECIMALS 2
*      VALUE '123456789012345.34'.

NEW-LINE.
WRITE : GV_NUM7.
WRITE : GV_NUM77.

"D, T
DATA : GV_NUM9 TYPE D.
DATA : GV_NUM10 TYPE T.

GV_NUM9 = SY-DATUM.
GV_NUM9 = SY-DATUM - 1.
GV_NUM10 = SY-UZEIT.
GV_NUM10 = SY-UZEIT - 60.

NEW-LINE.
WRITE : GV_NUM9, GV_NUM10.

"I관련 연산 명령어
DATA : GV_NUM11 TYPE I VALUE 3.
DATA : GV_NUM12 TYPE I VALUE 2.
DATA : GV_RESULT TYPE I.

NEW-LINE.
GV_RESULT = GV_NUM11 + GV_NUM12.
WRITE : GV_RESULT.

"GV_NUM12에 더해짐
ADD GV_NUM11 TO GV_NUM12.

NEW-LINE.
GV_RESULT = GV_NUM11 - GV_NUM12.
WRITE : GV_RESULT.

"GV_NUM12에 빼짐
SUBTRACT GV_NUM11 FROM GV_NUM12.

NEW-LINE.
GV_RESULT = GV_NUM11 * GV_NUM12.
WRITE : GV_RESULT.

"GV_NUM11에 곱해짐
MULTIPLY GV_NUM11 BY GV_NUM12.

NEW-LINE.
GV_RESULT = GV_NUM11 / GV_NUM12.
WRITE : GV_RESULT.

"GV_NUM11에 나눠짐
DIVIDE GV_NUM11 BY GV_NUM12.

DATA : GV_NUM13 TYPE I VALUE 5.
DATA : GV_NUM14 TYPE I VALUE 2.

"DIV - INTEGER 나누기 / MOD - INTEGER 나머지

NEW-LINE.
GV_RESULT = GV_NUM13 DIV GV_NUM14.
WRITE : 'DIV', GV_RESULT.

NEW-LINE.
GV_RESULT = GV_NUM13 MOD GV_NUM14.
WRITE : GV_RESULT.

"P관련 명령어
DATA : GV_NUM15 TYPE P DECIMALS 2 VALUE '2.17'.
DATA : GV_NUM16 TYPE P DECIMALS 2 VALUE '5.43'.
DATA : GV_RESULT2 TYPE P DECIMALS 2.

GV_RESULT = GV_NUM15 / GV_NUM16.
WRITE : / GV_RESULT.

GV_RESULT = GV_NUM15 * GV_NUM16.
WRITE : / GV_RESULT.

GV_RESULT2 = GV_NUM15 - GV_NUM16.
WRITE : / GV_RESULT2.

"ABS - 절대값
GV_RESULT2 = ABS( GV_RESULT2 ).
WRITE : / 'ABS', GV_RESULT2.

DATA : GV_RESULT22 TYPE P DECIMALS 2.
"CEIL - 해당 값보다 작지 않은 가장 큰 정수
GV_RESULT22 = CEIL( GV_RESULT2 ).
WRITE : / 'CEIL', GV_RESULT22.

"FLOOR - CEIL 반대
GV_RESULT22 = FLOOR( GV_RESULT2 ).
WRITE : / 'FLOOR', GV_RESULT22.

"TRUNC - 소수점을 버리고 정수만 남긴다
GV_RESULT22 = TRUNC( GV_RESULT2 ).
WRITE : / 'TRUNC', GV_RESULT22.

"FRAC - 소수점 이하 자리만 남긴다
GV_RESULT22 = FRAC( GV_RESULT2 ).
WRITE : / 'FRAC', GV_RESULT22.


""""""""""""""""""""""""""""""""""""""""""""""""""""""
"CHAR 선언
DATA : GV_CHAR3 TYPE C LENGTH 2.
DATA : GV_CHAR4 TYPE C LENGTH 2 VALUE 'EF'.
DATA : GV_CHAR2 TYPE C.
DATA : GV_CHAR1.
DATA : GV_CHAR5(1).
DATA : GV_CHAR55(10) TYPE C.
DATA : GV_CHAR6(3) VALUE 'ASD'.
DATA : GV_LEN TYPE I.

GV_CHAR1 = 'A'.
GV_CHAR2 = 'B'.
GV_CHAR3 = 'CD'.
GV_CHAR5 = 'GHI'.

GV_LEN = STRLEN( GV_CHAR6 ).

WRITE : / GV_CHAR1,
        / GV_CHAR2,
        / GV_CHAR3,
        / GV_CHAR4,
        / GV_CHAR5,
        / GV_CHAR6,
        / GV_LEN.

CONSTANTS : GC_CHAR11(10) VALUE 'CONSTANTS'.

*GC_CHAR11 = '111'. "에러남

WRITE : / GC_CHAR11.

"CHAR 관련 명령어

"FIND
DATA : GV_CHAR7(4).
DATA : GV_FIND.
GV_CHAR7 = 'ABAP'.
GV_FIND = 'B'.

FIND GV_FIND IN GV_CHAR7.
IF SY-SUBRC = 0.
  WRITE : / 'OK!'.
ELSE.
  WRITE : / 'WRONG!'.
ENDIF.

"REPLACE
DATA : GV_CHAR8(4).
DATA : GV_CHAR9.
DATA : GV_CHAR10(4).

GV_CHAR8 = 'ABAP'.
GV_CHAR9 = 'GGGG'.
GV_CHAR10 = 'GGGG'.

WRITE : / GV_CHAR8,
        / GV_CHAR9,
        / GV_CHAR10.


REPLACE 'A' IN GV_CHAR8 WITH 'P'.
WRITE : / GV_CHAR8.

REPLACE GV_CHAR8+1(1) IN GV_CHAR8 WITH 'J'.
WRITE : / GV_CHAR8.

"PJAP
GV_CHAR8+1(2) = 'TT'.
WRITE : / GV_CHAR8.

*DATA(str) = `Hallo`.
*REPLACE `a` IN str WITH `e`.
*cl_demo_output=>display( str ).

"TRANSLATE
DATA : GV_CHAR11(4).
GV_CHAR11 = 'ABCD'.
TRANSLATE GV_CHAR11 TO LOWER CASE.
WRITE : / GV_CHAR11.
TRANSLATE GV_CHAR11 TO UPPER CASE.
WRITE : / GV_CHAR11.

"SHIFT
DATA : GV_CHAR12(4).
GV_CHAR12 = '1234'.
SHIFT GV_CHAR12.
WRITE : / GV_CHAR12.

"CONDENSE
DATA : GV_CHAR13(10).
DATA : GV_CHAR13_2(10).
DATA : GV_CHAR13_3(10).
GV_CHAR13 = 'AB     CD'.
GV_CHAR13_2 = GV_CHAR13.
WRITE : / GV_CHAR13.
*CONDENSE GV_CHAR13 NO-GAPS.
CONDENSE GV_CHAR13.
WRITE : / GV_CHAR13.

CONDENSE GV_CHAR13_2 NO-GAPS.
WRITE : / GV_CHAR13_2.

GV_CHAR13_3 = GV_CHAR13.
CONDENSE GV_CHAR13_3 NO-GAPS.
WRITE : / GV_CHAR13_3.

"OVERLAY / 해당 위치에 빈 값이 있을 경우
DATA : GV_CHAR14(5).
DATA : GV_CHAR15(5).
DATA : GV_CHAR16(2).
DATA : GV_CHAR17(1).

GV_CHAR14 = 'A B C'.
GV_CHAR15 = '11111'.
GV_CHAR16 = '11'.
GV_CHAR17 = '1'.

WRITE : / GV_CHAR14, / GV_CHAR15.

OVERLAY GV_CHAR14 WITH GV_CHAR15.
WRITE : / GV_CHAR14.

OVERLAY GV_CHAR14 WITH GV_CHAR16.
WRITE : / GV_CHAR14.

OVERLAY GV_CHAR14 WITH GV_CHAR17.
WRITE : / GV_CHAR14.

"CONCATENATE
DATA : GV_CHAR18(2),
       GV_CHAR19(2),
       GV_CHAR20(4).

GV_CHAR18 = 'AA'.
GV_CHAR19 = 'BB'.

CONCATENATE GV_CHAR18 GV_CHAR19 INTO GV_CHAR20.
WRITE : / GV_CHAR20.

"SPLIT
DATA : GV_CHAR21(5),
       GV_CHAR22(2),
       GV_CHAR23(2).

GV_CHAR21 = 12345.

SPLIT GV_CHAR21 AT '3' INTO GV_CHAR22 GV_CHAR23.
WRITE : / GV_CHAR21,
        / GV_CHAR22,
        / GV_CHAR23.

GV_CHAR21 = 'AB/CD'.

SPLIT GV_CHAR21 AT '/' INTO GV_CHAR22 GV_CHAR23.
WRITE : / GV_CHAR21,
        / GV_CHAR22,
        / GV_CHAR23.

"""""""""""""""""""""""""""""""""""""""""""""""""
"조건문 : IF / CASE / DO
DATA : GV_CAL1 TYPE I,
       GV_CAL2 TYPE I,
       GV_CAL3 TYPE I.

GV_CAL1 = 3.
GV_CAL2 = 2.

GV_CAL3 = GV_CAL1 + GV_CAL2.

IF GV_CAL3 = 3.
  WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 3'.
ELSEIF GV_CAL3 = 4.
  WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 4'.
ELSE.
  WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 5'.
ENDIF.

IF GV_CAL1 = GV_CAL2.
  MESSAGE '같다' TYPE 'S'.
ELSE.
*  MESSAGE '다르다' TYPE 'E'.
  MESSAGE '다르다' TYPE 'S' DISPLAY LIKE 'E'.
ENDIF.

IF GV_CAL1 EQ GV_CAL2.
  MESSAGE '같다' TYPE 'S'.
ELSE.
*  MESSAGE '다르다' TYPE 'E'.
  MESSAGE '다르다' TYPE 'S' DISPLAY LIKE 'E'.
ENDIF.

IF GV_CAL1 <> GV_CAL2.
  MESSAGE '다르네' TYPE 'I'.
ENDIF.

IF GV_CAL1 NE GV_CAL2.
*  MESSAGE '다르네' TYPE 'I' DISPLAY LIKE 'S'.
*  MESSAGE '다르네' TYPE 'I' DISPLAY LIKE 'W'.
*  MESSAGE '다르네' TYPE 'I' DISPLAY LIKE 'E'.
  MESSAGE '다르네' TYPE 'I' DISPLAY LIKE 'A'.
ENDIF.

IF GV_CAL1 > GV_CAL2.
  MESSAGE 'GC_CAL1이 더 크다' TYPE 'S'.
ENDIF.

IF GV_CAL1 GT GV_CAL2.
  MESSAGE 'GC_CAL1이 더 크다' TYPE 'S'.
ENDIF.

IF GV_CAL1 >= GV_CAL2.
  MESSAGE 'GC_CAL1이 더 크거나 같다' TYPE 'S'.
ENDIF.

IF GV_CAL1 GE GV_CAL2.
  MESSAGE 'GC_CAL1이 더 크거나 같다' TYPE 'S'.
ENDIF.

IF GV_CAL1 < GV_CAL2.
  MESSAGE 'GC_CAL1이 더 작다' TYPE 'S'.
ENDIF.

IF GV_CAL1 LT GV_CAL2.
  MESSAGE 'GC_CAL1이 더 작다' TYPE 'S'.
ENDIF.

IF GV_CAL1 <= GV_CAL2.
  MESSAGE 'GC_CAL1이 더 작거나 같다' TYPE 'S'.
ENDIF.

IF GV_CAL1 LE GV_CAL2.
  MESSAGE 'GC_CAL1이 더 작거나 같다' TYPE 'S'.
ENDIF.

GV_CAL1 = 1.
GV_CAL2 = 3.

IF GV_CAL1 > 0 AND GV_CAL2 >= 0.
  MESSAGE '둘 모두 TRUE' TYPE 'S'.
ENDIF.

IF GV_CAL1 > 1 OR GV_CAL2 > 2.
  MESSAGE '둘 중 하나 TRUE' TYPE 'S'.
ENDIF.

IF ( GV_CAL1 = 1 OR GV_CAL2 > 3 )
AND ( GV_CAL1 > 2 OR GV_CAL2 = 3 ).
  MESSAGE 'AND 조건 TRUE' TYPE 'S'.
ENDIF.

IF ( GV_CAL1 = 1 AND GV_CAL2 > 3 )
OR ( GV_CAL1 = 1 AND GV_CAL2 = 3 ).
  MESSAGE 'OR 조건 TRUE' TYPE 'S'.
ENDIF.

CASE GV_CAL3.
  WHEN 3.
    WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 3'.
  WHEN 4.
    WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 4'.
  WHEN OTHERS.
    WRITE : / 'GV_CAL3 : ', GV_CAL3,  'ANSWER : 5'.
ENDCASE.

DO 3 TIMES.
  GV_CAL3 = GV_CAL3 - 1.

  IF GV_CAL3 <> 3.
    WRITE : / GV_CAL3.
  ENDIF.
ENDDO.

DO GV_CAL3 TIMES.
  WRITE : / '123'.
ENDDO.

""""""""""""""""""""""""""""""""""""
DATA : BEGIN OF GS_DATA1,
        GV_CHAR1(1),
        GV_CHAR2(1),
        GV_CHAR3(1),
       END OF GS_DATA1.

DATA : BEGIN OF GS_DATA111.
DATA :  GV_CHAR1(1),
        GV_CHAR2(1),
        GV_CHAR3(1).
DATA : END OF GS_DATA111.

GS_DATA1-GV_CHAR1 = 'A'.
GS_DATA1-GV_CHAR2 = 'B'.
GS_DATA1-GV_CHAR3 = 'C'.

WRITE : / GS_DATA1.
WRITE : / GS_DATA1-GV_CHAR1,
          GS_DATA1-GV_CHAR2.

TYPES : BEGIN OF TY_DATA2,
         GV_CHAR1(1),
         GV_CHAR2(1),
         GV_CHAR3(1),
        END OF TY_DATA2.

TYPES : BEGIN OF TY_DATA22.
TYPES :  GV_CHAR1(1),
         GV_CHAR2(1),
         GV_CHAR3(1).
TYPES : END OF TY_DATA22.

DATA : GS_DATA3 TYPE TY_DATA2.
DATA : GS_DATA4 LIKE GS_DATA3.

GS_DATA3-GV_CHAR1 = 'A'.
GS_DATA3-GV_CHAR2 = 'A'.
GS_DATA3-GV_CHAR3 = 'A'.

TYPES : BEGIN OF TY_DATA5,
         CHAR1(1),
         CHAR2(1),
         CHAR3(1),
        END OF TY_DATA5.

DATA : GS_DATA6 TYPE TY_DATA5.
DATA : GS_DATA7 LIKE GS_DATA6.

GS_DATA6-CHAR1 = 'A'.
GS_DATA6-CHAR2 = 'B'.
GS_DATA6-CHAR3 = 'C'.

GS_DATA7-CHAR1 = GS_DATA6-CHAR3.
GS_DATA7-CHAR2 = GS_DATA6-CHAR2.
GS_DATA7-CHAR3 = GS_DATA6-CHAR1.

WRITE : / GS_DATA6.
WRITE : / GS_DATA7.

CLEAR : GS_DATA7.

MOVE GS_DATA6 TO GS_DATA7.

WRITE : / GS_DATA6.
WRITE : / GS_DATA7.

DATA : BEGIN OF GS_DATA8,
        CHAR1(1),
        CHAR2(1),
        CHAR3(1),
       END OF GS_DATA8.

DATA : BEGIN OF GS_DATA9,
        CHAR3(1),
        CHAR2(1),
        CHAR1(1),
       END OF GS_DATA9.

GS_DATA8-CHAR1 = 'A'.
GS_DATA8-CHAR2 = 'B'.
GS_DATA8-CHAR3 = 'C'.

MOVE GS_DATA8 TO GS_DATA9.

WRITE : / 'F1 - CHAR3', GS_DATA9-CHAR3,
        / 'F1 - CHAR2', GS_DATA9-CHAR2,
        / 'F1 - CHAR1', GS_DATA9-CHAR1.

IF GS_DATA8 = GS_DATA9.
  MESSAGE '구조체가 같다' TYPE 'S'.
ELSEIF GS_DATA8 <> GS_DATA9.
  MESSAGE '구조체가 다르다' TYPE 'S' DISPLAY LIKE 'E'.
ENDIF.

CLEAR : GS_DATA9.

MOVE-CORRESPONDING GS_DATA8 TO GS_DATA9.

WRITE : / 'F1 - CHAR3', GS_DATA9-CHAR3,
        / 'F1 - CHAR2', GS_DATA9-CHAR2,
        / 'F1 - CHAR1', GS_DATA9-CHAR1.

IF GS_DATA8 = GS_DATA9.
  MESSAGE '구조체가 같다' TYPE 'S'.
ELSEIF GS_DATA8 <> GS_DATA9.
  MESSAGE '구조체가 다르다' TYPE 'S' DISPLAY LIKE 'E'.
ENDIF.

TYPES : BEGIN OF TY_DATA10,
         CHAR1,
         CHAR2,
         CHAR3,
        END OF TY_DATA10.

DATA : BEGIN OF GS_DATA11.
INCLUDE TYPE TY_DATA10.
DATA : CHAR4.
DATA : END OF GS_DATA11.

DATA : BEGIN OF GS_DATA12,
        CHAR1,
        CHAR2,
        CHAR3,
       END OF GS_DATA12.

DATA : BEGIN OF GS_DATA13.
INCLUDE STRUCTURE GS_DATA12.
*DATA : CHAR3. "중복으로 에러남
DATA : CHAR4.
DATA : END OF GS_DATA13.

"""""""""""""""""""""""""""""""""""""""""""""""""
*INSERT GS_DATA INTO TABLE GT_DATA.         "KEY
*INSERT GS_DATA INTO       GT_DATA INDEX 2.
*
*APPEND GS_DATA TO GT_DATA.
*
*COLLECT GS_DATA INTO GT_DATA.
*
*MODIFY TABLE GT_DATA FROM GS_DATA.                "KEY
*MODIFY       GT_DATA FROM GS_DATA TRANSPORTING F1.
*MODIFY       GT_DATA FROM GS_DATA INDEX SY-TABIX. "LOOP 안에서
*
*DELETE TABLE GT_DATA FROM GS_DATA.                "KEY
*DELETE       GT_DATA               WHERE F1 = 'AAA'.
*DELETE       GT_DATA               INDEX 2.
*
*READ TABLE GT_DATA INTO GS_DATA WITH KEY F1 = 'AAA'. "KEY

TYPES : BEGIN OF TY_DATA14,
         CHAR1(10),
         CHAR2(10),
         CHAR3(10),
        END OF TY_DATA14.

DATA : GS_DATA15 TYPE TY_DATA14.
DATA : GT_DATA15 TYPE TABLE OF TY_DATA14.

GS_DATA15-CHAR1 = 'AAA'.
GS_DATA15-CHAR2 = 'BBB'.
GS_DATA15-CHAR3 = 'CCC'.
APPEND GS_DATA15 TO GT_DATA15.

DATA : BEGIN OF GS_DATA16,
        CHAR1(10),
        CHAR2(10),
        CHAR3(10),
       END OF GS_DATA16.

DATA : GS_DATA17 LIKE GS_DATA16.
DATA : GT_DATA17 LIKE TABLE OF GS_DATA16.

GS_DATA17-CHAR1 = 'AAA'.
GS_DATA17-CHAR2 = 'BBB'.
GS_DATA17-CHAR3 = 'CCC'.
INSERT GS_DATA17 INTO TABLE GT_DATA17.

CLEAR GS_DATA17.
MOVE GS_DATA15 TO GS_DATA17.
APPEND GS_DATA17 TO GT_DATA17.

LOOP AT GT_DATA17 INTO GS_DATA17.
  WRITE : / GS_DATA17.
ENDLOOP.

SORT GT_DATA17.
SORT GT_DATA17 ASCENDING.
SORT GT_DATA17 DESCENDING.

SORT GT_DATA17 BY CHAR1 ASCENDING CHAR2 DESCENDING.

DATA : LV_CNT TYPE I.

DESCRIBE TABLE GT_DATA17 LINES LV_CNT.

DATA : BEGIN OF GS_DATA18,
        CHAR1(10),
        NUM TYPE I,
       END OF GS_DATA18.

DATA : GT_DATA18 LIKE TABLE OF GS_DATA18.

CLEAR GS_DATA18.
GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 1.
COLLECT GS_DATA18 INTO GT_DATA18.

CLEAR GS_DATA18.
GS_DATA18-CHAR1 = 'BBB'.
GS_DATA18-NUM = 2.
COLLECT GS_DATA18 INTO GT_DATA18.

CLEAR GS_DATA18.
GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 3.
COLLECT GS_DATA18 INTO GT_DATA18.

CLEAR GS_DATA18.
GS_DATA18-CHAR1 = 'BBB'.
GS_DATA18-NUM = 4.
COLLECT GS_DATA18 INTO GT_DATA18.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

CLEAR GS_DATA18.
GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 999.
MODIFY TABLE GT_DATA18 FROM GS_DATA18.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18.
  GS_DATA18-NUM = 888.

  MODIFY GT_DATA18 FROM GS_DATA18 INDEX SY-TABIX.
*  MODIFY GT_DATA18 FROM GS_DATA18.
ENDLOOP.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18.
  IF GS_DATA18-CHAR1 = 'AAA'.
    GS_DATA18-NUM = 777.
  ENDIF.

  MODIFY GT_DATA18 FROM GS_DATA18 INDEX SY-TABIX.
ENDLOOP.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

LOOP AT GT_DATA18 INTO GS_DATA18 WHERE CHAR1 = 'AAA'.
  GS_DATA18-NUM = 666.

  MODIFY GT_DATA18 FROM GS_DATA18.
ENDLOOP.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

READ TABLE GT_DATA18 INTO GS_DATA18 INDEX 1.

DELETE TABLE GT_DATA18 FROM GS_DATA18.
CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

DELETE GT_DATA18 WHERE CHAR1 = 'BBB'.
CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 1.
APPEND GS_DATA18 TO GT_DATA18.

GS_DATA18-CHAR1 = 'BBB'.
GS_DATA18-NUM = 2.
APPEND GS_DATA18 TO GT_DATA18.

GS_DATA18-CHAR1 = 'AAA'.
GS_DATA18-NUM = 3.
APPEND GS_DATA18 TO GT_DATA18.

GS_DATA18-CHAR1 = 'BBB'.
GS_DATA18-NUM = 4.
APPEND GS_DATA18 TO GT_DATA18.

SORT GT_DATA18.
DELETE ADJACENT DUPLICATES FROM GT_DATA18.
CL_DEMO_OUTPUT=>DISPLAY( GT_DATA18 ).

DATA : BEGIN OF GS_DATA19,
        CHAR1(10),
        CHAR2(10),
        NUM TYPE I,
       END OF GS_DATA19.

DATA : GT_DATA19 LIKE TABLE OF GS_DATA19.

CLEAR GS_DATA19.
GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-CHAR2 = '가'.
GS_DATA19-NUM = 1.
APPEND GS_DATA19 TO GT_DATA19.

CLEAR GS_DATA19.
GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-CHAR2 = '다'.
GS_DATA19-NUM = 2.
APPEND GS_DATA19 TO GT_DATA19.

CLEAR GS_DATA19.
GS_DATA19-CHAR1 = 'AAA'.
GS_DATA19-CHAR2 = '나'.
GS_DATA19-NUM = 3.
APPEND GS_DATA19 TO GT_DATA19.

CLEAR GS_DATA19.
GS_DATA19-CHAR1 = 'BBB'.
GS_DATA19-CHAR2 = '다'.
GS_DATA19-NUM = 4.
APPEND GS_DATA19 TO GT_DATA19.

CL_DEMO_OUTPUT=>DISPLAY( GT_DATA19 ).

DATA : GT_DATA20 LIKE GT_DATA19.
DATA : GT_DATA21 LIKE GT_DATA19.

MOVE GT_DATA19 TO GT_DATA20.
MOVE GT_DATA19 TO GT_DATA21.

SORT GT_DATA19.
DELETE ADJACENT DUPLICATES FROM GT_DATA19.
*DELETE ADJACENT DUPLICATES FROM GT_DATA19 COMPARING ALL FIELDS.
CL_DEMO_OUTPUT=>DISPLAY( GT_DATA19 ).

SORT GT_DATA20.
DELETE ADJACENT DUPLICATES FROM GT_DATA20 COMPARING CHAR1.
CL_DEMO_OUTPUT=>DISPLAY( GT_DATA20 ).

READ TABLE GT_DATA21 INTO GS_DATA19 WITH TABLE KEY CHAR1 = 'AAA'
                                                   CHAR2 = '가'.
IF SY-SUBRC = 0.
  MESSAGE '찾았다!' TYPE 'I'.
ENDIF.

READ TABLE GT_DATA21 INTO GS_DATA19 WITH KEY CHAR2 = '가'.
IF SY-SUBRC = 0.
  MESSAGE '찾았다2' TYPE 'I'.
ENDIF.

* BINARY SEARCH
